# -*- coding: utf-8 -*-
"""Angle_CNN_with_augmentation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XyJ81NPnyIFCLHrr2ij91xUgKtLMWNH5
"""

import numpy as np
import pandas as pd
from pathlib import Path
import tensorflow as tf
from tensorflow.keras import layers
import cv2
import os
import PIL
import tensorflow as tf
import cv2
from keras.models import Sequential
from keras.layers import Dense, Conv1D, Flatten
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
from tensorflow.keras import layers, Input
from tensorflow import keras

from google.colab import drive
drive.mount('/content/drive')

path_to_data = Path("/content/drive/My Drive/machine-learning-in-science-ii-2023")

training_data = pd.read_csv(path_to_data/'training_norm.csv')
training_data = training_data.tail(-1)
training_data.head
angles = training_data.loc[:,'angle']
y = np.array(angles)

print(len(y))

data_dir = Path(path_to_data/'training_data'/'combined')
data_dir
all_pictures = list(data_dir.glob('*'))

print(len(all_pictures))

X = []
for image in all_pictures:
  img = cv2.imread(str(image))
  resized_img = cv2.resize(img,(180,180))
  X.append(resized_img)

X = np.array(X)

print(X.shape)
xtrain, xtest, ytrain, ytest=train_test_split(X, y, test_size=0.15)

data_augmentation = keras.Sequential([
    layers.experimental.preprocessing.RandomZoom(0.3)
])

image_shape = (180,180)


model = tf.keras.Sequential(
    [data_augmentation,
        Input(shape=image_shape+(3,)),
        layers.Conv2D(32, 3, padding="valid", activation="relu"),
        layers.MaxPooling2D(),
        layers.Conv2D(64, 3, activation="relu"),
        layers.MaxPooling2D(),
        layers.Conv2D(128, 3, activation="relu"),
        layers.Flatten(),
        layers.Dense(64, activation="relu"),
        layers.Dense(1),
    ],
    name='CNN_speed'
)
model.compile(loss="mse", optimizer="adam")

model.fit(xtrain, ytrain, batch_size=12,epochs=30, verbose=0)

ypred = model.predict(xtest)
print(model.evaluate(xtrain, ytrain))
print("MSE: %.4f" % mean_squared_error(ytest, ypred))

x_ax = range(len(ypred))
plt.scatter(x_ax, ytest, s=5, color="blue", label="original")
plt.plot(x_ax, ypred, lw=0.8, color="red", label="predicted")
plt.legend()
plt.show()

